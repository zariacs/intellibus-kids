# nutriLab Backend Documentation
nutriLab is a web application designed to transform dietary management for patients with Irritable Bowel Syndrome (IBS) by providing personalized, AI-generated meal plans that are carefully reviewed and approved by medical professionals. The backend of nutriLab serves as the foundation of this innovative platform, managing critical tasks such as user authentication, data storage, AI-driven meal plan generation, and real-time data ingestion. This document offers a detailed exploration of the backend architecture, its components, and how they collaborate to deliver a seamless, secure, and scalable experience for both patients and doctors.
The core of nutriLab’s backend is built using FastAPI, a modern Python web framework renowned for its high performance and support for asynchronous operations. FastAPI drives the system’s ability to process requests efficiently, making it an ideal choice for handling real-time data updates and user interactions. The backend is organized into two distinct services: the main FastAPI server, which oversees user requests and database interactions, and a separate AI service, which focuses on generating meal plans using advanced machine learning techniques. This modular design enhances maintainability and allows each service to scale independently as the application grows.
Authentication forms the first layer of interaction with the backend, ensuring that only authorized users—patients and doctors—can access the system. This is managed through Clerk, a user management platform that streamlines sign-ups, logins, and role-based access control. When a user logs in, Clerk validates their credentials and provides a secure token, which the backend uses to verify all subsequent requests. This token-based approach safeguards sensitive data, such as patient medical histories and meal plans, while additional authorization checks ensure doctors can only view and edit meal plans assigned to them.
After authentication, users engage with the system through RESTful API endpoints provided by the main FastAPI server. These endpoints enable a range of functions, including creating patient profiles, submitting meal plan requests, and retrieving approved plans. When a patient enters their medical history and dietary preferences, the data is securely sent to the backend, validated, and stored in Supabase, a PostgreSQL-based database chosen for its scalability, real-time features, and seamless integration with FastAPI. Supabase efficiently manages the growing volume of user data, ensuring the system remains responsive as nutriLab expands.
The standout feature of nutriLab’s backend is its AI-driven meal plan generation, handled by the dedicated AI service. When a patient requests a meal plan, the main server retrieves their profile data from Supabase and forwards it to the AI service through an internal API call. The AI service processes this information using a Large Language Model (LLM) paired with a Retrieval-Augmented Generation (RAG) pipeline. The RAG pipeline enhances the LLM by retrieving relevant dietary research and clinical guidelines from a knowledge base, ensuring that meal plans are both personalized and scientifically accurate.

A defining capability of nutriLab is its real-time data ingestion system, which keeps the RAG pipeline’s knowledge base up to date with the latest dietary research. This process begins with a module in the AI service that fetches data from trusted sources like PubMed, WHO, and medical journals using their APIs. The retrieved data is processed and converted into vector embeddings then stored in Pinecone, a vector database optimized for fast retrieval. This allows the AI to access current information efficiently during meal plan generation. The ingestion operates continuously in the background and updates the vector store as new research emerges, ensuring meal plans reflect the most recent scientific insights.

Once the AI generates a meal plan, it is sent back to the main server and stored in Supabase with a “pending” status, signaling that it awaits doctor review. Doctors log in to access a list of pending meal plans, review them, make necessary adjustments, and approve them. Upon approval, the backend updates the plan’s status to “approved” and notifies the patient, who can then view the finalized plan through the frontend, complete with meal details and doctor notes.
To refine the AI’s performance, doctor feedback is captured using LangFuse, a tool for monitoring LLM interactions. Each adjustment or comment from a doctor is logged and analyzed to improve the AI’s future outputs, creating a feedback loop that enhances the system’s accuracy over time. This integration of human expertise ensures that nutriLab’s meal plans become increasingly reliable and tailored to patient needs.
Scalability is a key consideration in the backend’s design. By separating the main server and AI service, each can be scaled independently to meet demand. For instance, if meal plan requests surge, additional AI service instances can be deployed. Supabase and Pinecone, both cloud-native and scalable, support this growth by efficiently handling increased data and retrieval demands. This architecture also simplifies updates and maintenance, allowing changes to one component without affecting the entire system.

Security is paramount, given the sensitive nature of healthcare data. All communication between the frontend and backend is encrypted via HTTPS, and Supabase stores data with encryption at rest. Token-based authentication restricts API access to authorized users, while the real-time ingestion process uses API keys and access controls to secure external data sources. These measures ensure compliance with data privacy standards and protect user information throughout the system.
Performance is optimized through FastAPI’s asynchronous capabilities, enabling concurrent request handling and low latency. The Pinecone vector store supports rapid similarity searches, speeding up the RAG pipeline, while background tasks for data ingestion minimize their impact on real-time operations. Error handling is robust, with graceful recovery from issues like AI generation failures or ingestion errors, ensuring reliability and a smooth user experience.

The backend integrates seamlessly with the Next.js frontend, communicating via RESTful APIs. 
